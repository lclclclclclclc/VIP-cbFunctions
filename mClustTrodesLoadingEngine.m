function [t, wv] = mClustTrodesLoadingEngine(fn, records_to_get, record_units)% [t, wv] = mClustTrodesLoadingEngine(fn, records_to_get, record_units)%% INPUTS:% fn = the file name of an exported .dat file from a Trodes recording containing spike waveforms and spike times% records_to_get = = a range of values% record_units = a flag taking one of 5 cases (1,2,3,4 or 5)%% OUTPUT:% t = n x 1: timestamps of each spike in file% wv = n x nCh x 32 waveforms%% define in/outnCh = 8;recordIndex = [];wv = [];t = [];%% new 4.4 input case for GUI ease of use, see docxif nargin == 2     % New "get" construction"    if strcmp(fn, 'get')        switch records_to_get            case 'ChannelValidity'                 t = true(1,nCh); return;            case 'ExpectedExtension'                t = '.dat'; return;            otherwise                error('Unknown get condition.');        end    else        error('2 argins requires "get" as the first argument.');    endend%% read in datafileData = readTrodesExtractedDataFile(fn);if (isempty(fileData))     disp(['File read error: ',fn]);    return;endif isempty(strfind(fileData.description, 'Spike waveforms'))    disp(['File does not contain spike waveforms: ',fn]);    return;endcompleteTimestamps = double(fileData.fields(1).data)/fileData.clockrate; completeTimestamps = 1e-4*round(1e4*completeTimestamps);%rounded to match precision of CellBase%% get custom params if three inputsif nargin == 3 %three input case restricting time window for spikes.  updates recordIndex if used    switch record_units      case 1        % implies that records_to_get is a timestamp list.         recordIndex = zeros(length(records_to_get),1);        for i=1:length(records_to_get)          hit = find(completeTimestamps==records_to_get(i),1,'first');          if (~isempty(hit))            recordIndex(i) = hit;          end        end      case 2        % implies that records_to_get  is a record number list        recordIndex = records_to_get;      case 3         %implies that records_to_get  is range of timestamps (a vector with 2 elements: a start and an end timestamp)         recordIndex = find((completeTimestamps >= records_to_get(1)) & (completeTimestamps <= records_to_get(2)));      case 4         %implies that records_to_get  is a range of records (a vector with 2 elements: a start and an end record number)         recordIndex = [records_to_get(1):records_to_get(2)]';      case 5         %asks to return the count of spikes (records_to_get should be [] in this case)         t = length(completeTimestamps);         return;    end    elseif nargin == 1    % default to using all timestamps         recordIndex = [1:length(completeTimestamps)];      end%% define t, wv t = completeTimestamps(recordIndex);  if (nargout > 1)    wv = zeros(length(t),32,nCh);    for fieldInd = 2:(min(length(fileData.fields),1+nCh))      wv(:,:,fieldInd-1) = double(fileData.fields(fieldInd).data(recordIndex,1:32))*fileData.voltage_scaling;        end    wv = permute(wv,[1 3 2]); end   